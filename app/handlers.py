from aiogram import Bot, Dispatcher, F , Router, types
from aiogram.types import Message, CallbackQuery, FSInputFile, InputFile
from aiogram.filters import CommandStart, Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.utils.callbackData import parse_callback
from sqlalchemy import select
import os

import app.keyboards as kb
import app.database.requests as rq
from app.database.models import async_session

router_user = Router()
bot = bot = os.getenv("BOT_TOKEN")

# –ì–ª–æ–±–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞ –¥–ª—è –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ —à–ª—è—Ö—É
BASE_DIR = "FKEP"
current_dir = BASE_DIR

async def browse_folders(message: types.Message):
    """
    –ü–æ—á–∏–Ω–∞—î –ø–µ—Ä–µ–≥–ª—è–¥ –ø–∞–ø–æ–∫ —ñ —Ñ–∞–π–ª—ñ–≤ –∑ –±–∞–∑–æ–≤–æ—ó –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó.
    """
    global current_dir
    current_dir = BASE_DIR
    items = kb.get_files_and_folders(current_dir)

    if not items:
        await message.answer("–£ —Ü—ñ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó –Ω–µ–º–∞—î —Ñ–∞–π–ª—ñ–≤ —á–∏ –ø–∞–ø–æ–∫.")
        return

    keyboard = kb.create_file_folder_buttons(current_dir)
    print("Call browse_folders")
    # await message.answer(f"–ü–æ—Ç–æ—á–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—è: {current_dir}", reply_markup=keyboard)

    return keyboard


async def handle_folder_callback(query: CallbackQuery):
    """
    –û–±—Ä–æ–±–ª—è—î –≤–∏–±—ñ—Ä —Ñ–∞–π–ª—É –∞–±–æ –ø–∞–ø–∫–∏ —á–µ—Ä–µ–∑ callback.
    """
    global current_dir

    # –†–æ–∑–ø–∞—Ä—Å–∏—Ç–∏ callback_data
    callback_data = query.data.split(":")
    item_type, item_name = callback_data[0], callback_data[1].replace("_", " ")

    if item_type == "folder":
        # –Ø–∫—â–æ —Ü–µ –ø–∞–ø–∫–∞
        new_dir = os.path.join(current_dir, item_name)

        if not os.path.exists(new_dir):
            await query.message.answer(f"–î–∏—Ä–µ–∫—Ç–æ—Ä—ñ—è {item_name} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞.")
            return

        current_dir = new_dir
        items = kb.get_files_and_folders(current_dir)

        if not items:
            await query.message.edit_text(f"–£ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó {item_name} –Ω–µ–º–∞—î —Ñ–∞–π–ª—ñ–≤ —á–∏ –ø–∞–ø–æ–∫.")
            return

        keyboard = kb.create_file_folder_buttons(current_dir)
        print("Call handle_folder_callback")
        await query.message.edit_text(f"–ü–æ—Ç–æ—á–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—è: {current_dir}", reply_markup=keyboard)
    elif item_type == "file":
        # –Ø–∫—â–æ —Ü–µ —Ñ–∞–π–ª
        print(f"–î–æ: {item_name}")
        file_name = item_name.replace(" ", "_")
        print(f"–ü—ñ—Å–ª—è: {file_name}")
        file_path = os.path.join(current_dir, file_name)

        if os.path.exists(file_path):
            try:
                file = FSInputFile(file_path)
                await query.message.answer_document(file)
            except Exception as e:
                await query.message.answer(f"–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è —Ñ–∞–π–ª—É: {str(e)}")
        else:
            await query.message.answer(f"–§–∞–π–ª '{file_name}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.")

    # –í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏ –Ω–∞ callback
    await query.answer()


@router_user.callback_query(F.data == "back_to_FKEP")
async def back_to_FKEP(callback: CallbackQuery):
    """
    –û–±—Ä–æ–±–ª—è—î –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –¥–æ –±–∞–∑–æ–≤–æ—ó –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó.
    """
    global current_dir
    current_dir = BASE_DIR
    print(f"Current_dir: {current_dir}")
    keyboard = kb.create_file_folder_buttons(current_dir)
    await callback.message.edit_text(
        
        "–£ –≤–∞—Å —î –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ 5 –∑–∞–≤–¥–∞–Ω–Ω—å, —è–∫–∏—Ö —â–µ –Ω–µ–º–∞—î –≤ –±–æ—Ç—ñ —ñ –ø–æ–ª—É—á–∏—Ç–∏ - –¥–æ–ø–æ–º–æ–≥—É –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∑ –ø—Ä–µ–∑–∏–Ω—Ç–∞—Ü—ñ—î—é, –ø—Ä–∞–∫—Ç–∏—á–Ω–æ—é –∑ –≥—Ä–∞—Ñ—ñ—á–Ω–æ–≥–æ –¥–∏–∑–∞–π–Ω—É, –≤–µ–±—Å–∞–π—Ç–æ–º, –≥—Ä–æ—é –Ω–∞ python, –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞ –∑ –¢–µ—Ö–Ω–æ–ª–æ–≥—ñ–π\n\n"
        "–ë—É–¥—å –ª–∞—Å–∫–∞ –Ω–µ —Å–∫–∏–¥—É–π—Ç–µ –∑–∞–≤–¥–∞–Ω–Ω—è –≤—ñ–¥ –ë–∞–ª–∞–±–∞–Ω–∏–∫–∞, —É –Ω–µ—ó —Ç–∞–∫ –≤—Å—ñ –∑–∞–≤–¥–∞–Ω–Ω—è –≤ –º—É–¥–ª—ñ\n\n"
        f"–ü–æ–≤–µ—Ä–Ω—É—Ç–æ –¥–æ –±–∞–∑–æ–≤–æ—ó –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó: {current_dir}", reply_markup=keyboard)

# –ù–∞–¥—ñ—Å–ª–∞—Ç–∏ –¥–æ–∫—É–º–µ–Ω—Ç –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ü—ñ—ó

DOWNLOADS_PATH = "downloads" 

if not os.path.exists(DOWNLOADS_PATH):
    os.makedirs(DOWNLOADS_PATH)

class SendDocument(StatesGroup):
    document = State()
    description = State()

@router_user.callback_query(lambda c: c.data == "to_send_content")
async def start_register(callback: CallbackQuery, state: FSMContext):
    await state.update_data(tg_id=callback.from_user.id)
    await state.set_state(SendDocument.document)
    await callback.message.answer("–ù–∞–¥—ñ—à–ª—ñ—Ç—å –≤–∞—à –¥–æ–∫—É–º–µ–Ω—Ç –≤ —Ñ–æ—Ä–º–∞—Ç—ñ –∞—Ä—Ö—ñ–≤—É")
    await callback.answer()  # –ó–∞–∫—Ä–∏–≤–∞—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è
    await bot.answer_callback_query(callback.id)

@router_user.message(SendDocument.document)
async def register_document(message: Message, state: FSMContext):
    if not message.document:
        await message.answer("–ë—É–¥—å –ª–∞—Å–∫–∞, –Ω–∞–¥—ñ—à–ª—ñ—Ç—å —Ñ–∞–π–ª.")
        return

    # –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–æ–∫—É–º–µ–Ω—Ç–∞ –∑ Telegram
    file_info = await bot.get_file(message.document.file_id)
    file_bytes_io = await bot.download_file(file_info.file_path)

    # –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ —Å—Ç–∞–Ω—ñ
    await state.update_data(file_bytes=file_bytes_io.read())
    await state.set_state(SendDocument.description)
    await message.answer("–§–∞–π–ª –æ—Ç—Ä–∏–º–∞–Ω–æ. –í–≤–µ–¥—ñ—Ç—å –æ–ø–∏—Å")

@router_user.message(SendDocument.description)
async def register_description(message: Message, state: FSMContext):
    await state.update_data(description=message.text)
    data = await state.get_data()
    
    tg_id = data.get('tg_id', message.from_user.id)  # –û—Ç—Ä–∏–º—É—î–º–æ tg_id –∑ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
    file_bytes = data.get("file_bytes")  # –®–ª—è—Ö –¥–æ —Ñ–∞–π–ª—É
    description = message.text  # –û–ø–∏—Å

    # –§–æ—Ä–º—É—î–º–æ —ñ–º'—è —Ñ–∞–π–ª—É –∑ tg_id —ñ –æ–ø–∏—Å–æ–º
    safe_description = description.replace(" ", "_").replace("/", "_")
    file_name = f'{tg_id}_{safe_description}.zip'
    file_path = os.path.join(DOWNLOADS_PATH, file_name)

    with open(file_path, "wb") as file:
        file.write(file_bytes)

    # –õ–æ–≥—ñ–∫–∞ –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ—ó –æ–±—Ä–æ–±–∫–∏ —Ñ–∞–π–ª—É (–∑–∞ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ—Å—Ç—ñ)
    await message.answer(
        f"–í–∞—à–µ –∑–∞–≤–¥–∞–Ω–Ω—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ.\n"
        f"–®–ª—è—Ö –¥–æ —Ñ–∞–π–ª—É: {file_name}\n"
    )
    
    await state.clear()


# –ü—Ä–æ—Ñ—ñ–ª—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
class GetUserInfo(StatesGroup):
    user_id = State()

@router_user.callback_query(lambda c: c.data == "to_check_progress")
async def check_user_progress(callback: CallbackQuery):
    tg_id = callback.from_user.id  # –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –æ—Ç—Ä–∏–º—É—î–º–æ Telegram ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞

    async with async_session() as session:
        async with session.begin():
            result = await session.execute(select(rq.User).where(rq.User.tg_id == tg_id))
            user = result.scalars().first()

    if user:
        user_info = (
            f"üë§ –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –ø—Ä–æ –≤–∞—à –ø—Ä–æ—Ñ—ñ–ª—å:\n"
            f"ID: {user.id}\n"
            f"Telegram ID: {user.tg_id}\n"
            f"–ü—Ä–æ–≥—Ä–µ—Å: {user.progress}\n"
            f"–ë–æ–Ω—É—Å–∏: {user.bonus}"
        )
        await callback.message.answer(user_info)
    else:
        await callback.message.answer("‚ùå –í–∞—à –ø—Ä–æ—Ñ—ñ–ª—å –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö. –ú–æ–∂–ª–∏–≤–æ, –≤–∏ —â–µ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω—ñ.")

    await callback.answer()  # –ó–∞–∫—Ä–∏–≤–∞—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è

# Heandler –Ω–∞ –≥–æ–ª–æ–≤–Ω—É
@router_user.callback_query(lambda c: c.data == "to_main")
async def to_main(callback: CallbackQuery):
    await callback.message.answer("–í–∏ –ø–æ–≤–µ—Ä–Ω—É–ª–∏—Å—å –Ω–∞ –≥–æ–ª–æ–≤–Ω—É —Å—Ç–æ—Ä—ñ–Ω–∫—É.")
    await callback.answer()
    await callback.message.answer('–í–∏–±–µ—Ä—ñ—Ç—å –Ω–∏–∂—á–µ –∫—É—Ä—Å —è–∫–∏–π –≤–∞—Å —Ü—ñ–∫–∞–≤–∏—Ç—å:', reply_markup=kb.course)
    await bot.answer_callback_query(callback.id)
